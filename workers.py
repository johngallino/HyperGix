import json
import sys
import ast
import shutil
import re
import os
from os import getcwd

import requests
import numpy as np
import spectral as s

import spectral.io.envi as envi
from osgeo import gdal
from PyQt5 import QtWidgets as qtw
from PyQt5 import QtCore as qtc
from PyQt5 import QtSql as qts

import config
from config import HYPERION_SCANS_PATH as DOWNLOAD_PATH

### Worker classes - NO GUI - can be threaded

class Databaser(qtw.QWidget):
    """" Class for interacting with the database """

    scansInDB = qtc.pyqtSignal(list)
    matsInDB = qtc.pyqtSignal(list)
    reportPixels = qtc.pyqtSignal(list, int)
    reportPixelSource = qtc.pyqtSignal(str, int, int)
    reportFilepath = qtc.pyqtSignal(str, str)
    addScanSuccess = qtc.pyqtSignal(str)
    delScanSuccess = qtc.pyqtSignal(str)
    delProfileSuccess = qtc.pyqtSignal(str)
    delPixelSuccess = qtc.pyqtSignal(str)
    raggedArrayAlert = qtc.pyqtSignal()
    reportMeans = qtc.pyqtSignal(list)

    mats = []

    def report_scans(self):
        scans = self.pull_scans()
        self.scansInDB.emit(scans)
    
    def report_mats(self):
        self.mats = self.pull_materials()
        self.matsInDB.emit(self.mats)
        self.create_materials_means_matrix()

    def pull_scans(self):
        ''' returns a list of scans in the database'''
        query = self.db.exec('SELECT id, nickname FROM scans')
        scans = []
        while query.next():
            if query.value(1) != 'None':
                scans.append(f'{query.value(0)} ({query.value(1)})')
            else:
                scans.append(query.value(0))
            # print(query.value(0), query.value(1))
        return scans

    def pull_materials(self):
        ''' returns a list of all materials in the database '''
        query1 = qts.QSqlQuery(self.db)
        query1.exec('SELECT * FROM materials')
        materials = []
        while query1.next():
            materials.append(query1.value(1))
        # print(materials)
        return materials
    
    def get_mid(self, material):
        ''' returns the material ID for a material name '''
        matQuery = qts.QSqlQuery(self.db)
        matQuery.prepare('SELECT mid FROM materials WHERE name=:material')
        matQuery.bindValue(':material', material)
        matQuery.exec_()
        target_mat = 'ERROR'
        if matQuery.next():
            target_mat = matQuery.value(0)
            return target_mat
        else:
            # print('no material in db matches', material)
            return None
    
    def add_scan(self, scanID, nickname='None'):
        ''' adds a hyperspectral image to the database '''
        # assume you receive an id like 'EO1H0140312014030110KF'

        if ':' in scanID or '/' in scanID:
            parts = scanID.split('/')
            i = len(parts) -1
            filepath = scanID
            fileFormat = scanID[-3:]
            scanID = parts[i].replace(f'.{fileFormat}', '')
        elif '.' in scanID:
            fileFormat = scanID[-3:]
            filepath = os.path.join(config.HYPERION_SCANS_PATH, scanID)
        else:
            fileFormat = 'L1R'
            filepath = os.path.join(config.HYPERION_SCANS_PATH, scanID, scanID + '.' + fileFormat)
            
        presenceCheck = qts.QSqlQuery(self.db)
        presenceCheck.prepare('SELECT * FROM scans WHERE id=:id')
        presenceCheck.bindValue(':id', scanID)
        presenceCheck.exec_()
        if not presenceCheck.next():
            present = False
            # print(f'{scanID} is not in the database currently')
        else:
            present = True
            # print(f'{id} already in database')

        def info_search(file, term, datalength):
            ''' use this method to pull data from gdal.info '''
            if file.find(term) != -1:
                i = file.find(term) + len(term)
                data = file[i:i+datalength]
                return data.rstrip()
            else:
                print(f"!!! Did not find '{term}'")
                return None

        def pull_numbers_from_line(file, i, term):
            ''' use this method to pull data from .MET file '''
            line = file[i]
            num = ''
            start = line.find(term) + len(term)
            if start != -1:
                num = line[start:].rstrip()
                return num
            else:
                print(f"!!! Did not find '{term}'")
                return None

        def pull_date_from_multispec_tiff(file):
            ''' use this method to pull data from a tiff file generated by Multispec '''

            # First lets find the exact line needed and store the linenumber as i
            lookup = 'Generated by MultiSpecUniversal'
            target = ''
            for line in file.splitlines():
                if lookup in line:
                    target = line
                    break
            
            print(f'using regex on line: {target}')

            datepattern = r'([0-9]+(-[0-9]+)+)'
            timepattern = r'[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]{1,3})?'

            date = re.search(datepattern, target)
            time = re.search(timepattern, target)

            if date and time:
                return date.group(), time.group()
            elif date:
                return date.group()
            else:
                print("!!! Did not find date or time values'")
                return None

        if not present:

            if os.path.isdir(os.path.join(config.HYPERION_SCANS_PATH, scanID)):
                filepath = os.path.join(config.HYPERION_SCANS_PATH, scanID, f'{scanID}.{fileFormat}')
                info = gdal.Info(filepath).split('Corner ')[0]
                print(info)

            else:
                info = gdal.Info(filepath).split('Corner ')[0]
                print(f'\nGDAL INFO for {scanID}.{fileFormat}')
                print('=======================================================')
                print(info)
                print('================== END GDAL INFO ======================\n')

            metapath = os.path.join(config.HYPERION_SCANS_PATH, scanID, f'{scanID}.MET')

            if os.path.exists(metapath):
                with open(metapath) as f:
                    lines = f.read()
                    f.seek(0,0)
                    linelist = f.readlines()
                    # print(lines)
                    f.close()

            elif os.path.exists(filepath.replace(filepath[:-3], 'MET')):
                metapath = filepath.replace(filepath[:-3], 'MET')
                with open(metapath) as f:
                    lines = f.read()
                    f.seek(0,0)
                    linelist = f.readlines()
                    # print(lines)
                    f.close()
            else:
                print(f'No metadata file found for {scanID}\n')
                linelist = None

            driver = info_search(info, 'Driver: ', 19)
            # print('DRIVER IS', driver)

            if 'LAN' in driver:
                from datetime import date as d
                try:
                    img = s.open_image(filepath)
                    rows = img.shape[0]
                    samples = img.shape[1]
                    bands = img.shape[2]

                    if img.interleave == 1:
                        interleave = 'BIL'
                    elif img.interleave == 2:
                        interleave = 'BIP'
                    elif img.interleave == 3:
                        interleave = 'BSQ'
                    else:
                        interleave = 'BIL'
                    
                    sensor = None
                    date = d.today().strftime("%b %d %Y")
                    time = None

                except Exception as e:
                    print(e)

            elif 'GTiff' in driver:
                img = gdal.Open(filepath)
                rows = img.RasterXSize
                samples = img.RasterYSize
                bands = img.RasterCount
                interleave = 'BIL'
                sensor = None
                if 'Generated by MultiSpecUniversalIntel' in gdal.Info(filepath):
                    date, time = pull_date_from_multispec_tiff(gdal.Info(filepath))
                    interleave = 'BSQ'
                else:
                    date = None
                    time = None
                    interleave = 'BSQ'

            elif 'HDF5' in driver:
                size = info_search(info, 'Size is ', 9).split(' ')
                rows = size[0]
                samples = size[1]
                swirList = info_search(info, 'List_Cw_Swir=', 1708).split(' ')
                vnirList = info_search(info, 'List_Cw_Vnir=', 648).split(' ')
                print('swirlist:', swirList)
                print('vnirList', vnirList)
                bands = len(swirList) + len(vnirList)
                bandcenters = swirList + vnirList
                print('total bands:', bands)
                interleave = 'BIL'
                sensor = None
                date = None
                time = None
                
            else:
                rows = info_search(info, 'Number of Along Track Pixels=', 4)
                samples = info_search(info, 'Number of Cross Track Pixels=', 4)
                bands = info_search(info, 'Number of Bands=', 3)
                interleave = info_search(info, 'Interleave Format=', 3)
                sensor = info_search(info, 'L1 File Generated By=', 15)
                datetime = info_search(info, 'Time of L1 File Generation=', 20)
                
                try:
                    dt = datetime.split(' ')
                    date = dt[0] +' '+ dt[1] + ' ' + dt[3]
                    time = dt[2]
                except:
                    date = datetime if datetime else None
                    time = None

            if linelist:
                c_lat = pull_numbers_from_line(linelist, 1, 'Site Latitude                ')
                c_lon = pull_numbers_from_line(linelist, 2, 'Site Latitude                ')
                ul_lat = pull_numbers_from_line(linelist, 22, ' = ')
                ul_lon = pull_numbers_from_line(linelist, 23, ' = ')
                ur_lon = pull_numbers_from_line(linelist, 24, ' = ')
                ur_lat = pull_numbers_from_line(linelist, 25, ' = ')
                ll_lon = pull_numbers_from_line(linelist, 26, ' = ')
                ll_lat = pull_numbers_from_line(linelist, 27, ' = ')
                lr_lon = pull_numbers_from_line(linelist, 28, ' = ')
                lr_lat = pull_numbers_from_line(linelist, 29, ' = ')
            else:
                c_lat = None 
                c_lon = None
                ul_lat = None
                ul_lon = None 
                ur_lat = None
                ur_lon = None
                ll_lon = None
                ll_lat = None
                lr_lon = None
                lr_lat = None
        
            print('\nAdding the following to database...')
            print('id:', scanID)
            print('nickname:', nickname)
            print('rows:', rows)
            print('samples:', samples)
            print('bands:', bands)
            print('interleave:', interleave)
            print('sensor:', sensor)
            print('date:', date)
            print('time:', time)
            print('c_lat:', c_lat)
            print('c_lon:', c_lon)
            print('ul_lat:', ul_lat)
            print('ul_lon:', ul_lon)
            print('ur_lat:', ur_lat)
            print('ur_lon:', ur_lon)
            print('ll_lat:', ll_lat)
            print('ll_lon:', ll_lon)
            print('lr_lat:', lr_lat)
            print('lr_lon:', lr_lon)
            print('\n')

            insertQuery = qts.QSqlQuery(self.db)
            insertQuery.prepare(
                'INSERT INTO scans(id, nickname, filepath,'
                'rows, samples, bands, sensor, interleave, date, time,'
                'ul_lat, ul_lon, ur_lat, ur_lon, ll_lat, ll_lon, lr_lat,'
                'lr_lon, c_lat, c_lon) VALUES (:id, :nickname, :filepath,'
                ':rows, :samples, :bands, :sensor, :interleave, :date, :time,'
                ':ul_lat, :ul_lon, :ur_lat, :ur_lon, :ll_lat, :ll_lon, :lr_lat,'
                ':lr_lon, :c_lat, :c_lon)'
            )
            insertQuery.bindValue(':id', scanID)
            insertQuery.bindValue(':nickname', nickname)
            insertQuery.bindValue(':filepath', filepath)
            insertQuery.bindValue(':rows', rows)
            insertQuery.bindValue(':samples', samples)
            insertQuery.bindValue(':bands',bands)
            insertQuery.bindValue(':interleave', interleave)
            insertQuery.bindValue(':sensor', sensor)
            insertQuery.bindValue(':date', date)
            insertQuery.bindValue(':time', time)
            insertQuery.bindValue(':c_lat', c_lat)
            insertQuery.bindValue(':c_lon', c_lon)
            insertQuery.bindValue(':ul_lat', ul_lat)
            insertQuery.bindValue(':ul_lon', ul_lon)
            insertQuery.bindValue(':ur_lat', ur_lat)
            insertQuery.bindValue(':ur_lon', ur_lon)
            insertQuery.bindValue(':ll_lat', ll_lat)
            insertQuery.bindValue(':ll_lon', ll_lon)
            insertQuery.bindValue(':lr_lat', lr_lat)
            insertQuery.bindValue(':lr_lon', lr_lon)
            good = insertQuery.exec_()
            
            if good:
                print(f'scan {scanID} added successfully to db')
                if nickname != 'None':
                    self.addScanSuccess.emit(f'{scanID} ({nickname})')
                else:
                    self.addScanSuccess.emit(scanID)
                # send signal to add to the list
            else:
                print('SCAN NOT ADDED TO DATABASE!\n', insertQuery.lastError().text())
      
    def add_pixel(self, id, r, c, material ):
        ''' adds a pixel to the database '''
        presenceCheck = qts.QSqlQuery(self.db)
        presenceCheck.prepare('SELECT * FROM pixels WHERE source=:source AND row=:row AND col=:col')
        presenceCheck.bindValue(':source', id)
        presenceCheck.bindValue(':row', r)
        presenceCheck.bindValue(':col', c)
        presenceCheck.exec_()
        if not presenceCheck.next():
            print('source is:', id)
            filename = id[:-4]
            query1 = qts.QSqlQuery(self.db)
            query1.prepare('SELECT filepath, sensor from scans WHERE id = :id')
            query1.bindValue(':id', filename)
            query1.exec_()
            if query1.next():
                filepath = query1.value(0)
                if 'HYP' in query1.value(1):
                    # scan is a Hyperion scan
                    header = id.replace('L1R', 'hdr')
                    header = os.path.join(DOWNLOAD_PATH, id[:-4], header)
                    img = envi.open(header, filepath)
            
                else: #not Hyperion
                    try:
                        img = s.open_image(filepath)
                    except Exception as e:
                        print('Problem with file \n', e)
            
            spectra = ''
            for val in img[r,c]:
                spectra += str(val) + ' '

            print('spectra is:', spectra)

            print(f'That pixel is not in the database currently')
            # print('gonna add', id, r, c, material)

            target_mat = self.get_mid(material)

            insertQuery = qts.QSqlQuery(self.db)
            insertQuery.prepare('INSERT INTO pixels(source, row, col, material, spectra)'
                'VALUES (:source, :row, :col, :material, :spectra)'
                )
            insertQuery.bindValue(':source', id.replace('.L1R', ''))
            insertQuery.bindValue(':row', r)
            insertQuery.bindValue(':col', c)
            insertQuery.bindValue(':material', target_mat)
            insertQuery.bindValue(':spectra', spectra)
            good = insertQuery.exec_()

            if good:
                print(f'pixel {id} added successfully to db')
            else:
                print(insertQuery.lastError().text())

        else:
            present = True
            print(f'That pixel is already in database with material {presenceCheck.value(4)}')

    def add_material(self, name):
        ''' adds a new material to the database '''
        presenceCheck = qts.QSqlQuery(self.db)
        presenceCheck.prepare('SELECT * FROM materials WHERE name=:name')
        presenceCheck.bindValue(':name', name)

        presenceCheck.exec_()
        if not presenceCheck.next():
            present = False
            print(f'That material is not in the database currently. Adding it now...')

            insertQuery = qts.QSqlQuery(self.db)
            insertQuery.prepare('INSERT INTO materials (name) values (:name)')
            insertQuery.bindValue(':name', name)
            good = insertQuery.exec_()

            if good:
                print(f'{name} added successfully to db')
            else:
                print(insertQuery.lastError().text())
        else:
            present = True
            print(f'That material is already in the database')

    def change_scan_filepath_to_lan(self, path):
        ''' change the file path in DB to .lan for converted .tif scans '''
        newpath = path.replace('.tif', '.lan')
        query = qts.QSqlQuery(self.db)
        query.prepare('UPDATE scans SET filepath = :newpath WHERE filepath = :path')
        query.bindValue(':path', path)
        query.bindValue(':newpath', newpath)

        good = query.exec_()
        if good:
            print(f'\n{path} updated to {newpath}')
                #send signal to add to the list
        else:
            print('SCAN FILEPATH NOT UPDATED!\n', query.lastError().text())

    def delete_scan(self, scanID):
        ''' given a scan ID, deletes the file and removes from db'''
        
        query1 = qts.QSqlQuery(self.db)
        query1.prepare('SELECT filepath from scans where id = :scanID')
        query1.bindValue(':scanID', scanID)
        good = query1.exec_()

        if good:
            query1.next()
            filepath = query1.value(0)
            if '\\' in filepath:
                parts = filepath.split('\\')
            else:
                parts = filepath.split('/')

            query1 = qts.QSqlQuery(self.db)
            query1.prepare('DELETE from scans where filepath = :filepath')
            query1.bindValue(':filepath', filepath)
            good = query1.exec_()

            if good:

                print(f'{scanID} deleted from db')
                self.delScanSuccess.emit(scanID)

            else:
                print('ERROR!\n', query1.lastError().text())     
            
            ##### Currently scans are removed from the DB but the file is not deleted
            ##### UNCOMMENT BELOW TO ACTUALLY DELETE FILES ####
                
            # filename = parts[len(parts) - 1]
            # print(filename)
            # if filename[:-4] == parts[len(parts)-2]:
            #     import shutil
            #     directory = filepath.replace(filename, '')[:-1]
            #     try:
            #         shutil.rmtree(directory)
            #         print(directory, 'deleted from system')
            #     except Exception as e:
            #         print(e)
            #         qtw.QMessageBox.critical(
            #             None, 'Cannot Delete',
            #             'Could not delete: ',
            #             f'{e}')
                
            # else:
            #     try:
            #         os.remove(filepath)
            #         print(filepath, 'deleted from system')
            #     except Exception as e:
            #         print(e)
            #         qtw.QMessageBox.critical(
            #             None, 'Cannot Delete',
            #             'Could not delete: ',
            #             f'{e}')
        # else:
        #     print('ERROR!\n', query1.lastError().text()) 

    def delete_Profile(self, profile):
        ''' given a profile name, deletes it from db'''
        query1 = qts.QSqlQuery(self.db)
        query1.prepare('DELETE from materials where name = :profile')
        query1.bindValue(':profile', profile)
        good = query1.exec_()

        if good:
            print(f'{profile} deleted from db')
            self.delProfileSuccess.emit(profile)
        else:
            print('ERROR!\n', query1.lastError().text()) 

    def delete_pixel(self, pid):
        ''' deletes a pixel from db by given PID '''
        query1 = qts.QSqlQuery(self.db)
        query1.prepare('DELETE from pixels WHERE pid = :pid')
        query1.bindValue(':pid', pid)
        good = query1.exec_()

        if good:
            print(f'Pixel {pid} deleted from db')
            self.delPixelSuccess.emit(str(pid))
        else:
            print(query1.lastError().text())
    
    def report_pixels_for_material(self, name):
        ''' queries the database for all pixels belonging to a material '''
        mid = self.get_mid(name)
        query1 = qts.QSqlQuery(self.db)
        query1.prepare('SELECT pid, spectra, bands FROM pixels LEFT JOIN scans'
            ' on scans.id = pixels.source WHERE material = :material')
        query1.bindValue(':material', mid)
        query1.exec_()
        results=[]
        bandcounts = []

        while query1.next():
            results.append({str(query1.value(0)): query1.value(1)})
            bandcounts.append(int(query1.value(2)))

        if results:
            # print(str(len(results)) + f' Pixels for {name}')
            # print('Max num of bands is', max(bandcounts))
            # print(results)
            self.reportPixels.emit(results, max(bandcounts))

        else:
            # print(f'No pixels for {name}')
            # print('\n')
            self.reportPixels.emit(results, 242)
        
    def update_average_for_material(self, material, values):
        values = str(values)
        query1 = qts.QSqlQuery(self.db)
        # print('values:', values)
        # print('material:', material)
        query1.prepare('UPDATE materials SET spectra = :vals WHERE name = :material')
        query1.bindValue(':vals', values)
        query1.bindValue(':material', material)
        good = query1.exec_()

        # if good:
        #     print(f'average spectra for {material} updated')
        # else:
        #     print('query error:', query1.lastError().text())

    def report_info_for_pid(self, pid):
        ''' given a pixel ID (pid), returns row, column and source image from db '''
        pid = pid.text()
        # print(pid)
        query = qts.QSqlQuery(self.db)
        query.prepare('SELECT filepath, row, col from pixels LEFT JOIN scans on scans.id = pixels.source where pid = :pid')
        query.bindValue(':pid', pid)
        query.exec_()
        
        if query.next():
            # print('returning', query.value(0), query.value(1), query.value(2))
            self.reportPixelSource.emit(query.value(0), query.value(1), query.value(2))

    def report_data_for_fileID(self, id, mode):
        ''' given a scan id, returns filepath from db '''

        query = qts.QSqlQuery(self.db)
        query.prepare('SELECT filepath from scans where id = :id')
        query.bindValue(':id', id)
        query.exec_()
        
        if query.next():
            self.reportFilepath.emit(query.value(0), mode)
        else:
            self.reportFilepath.emit(f'ERR: no path in database for {id}')



    def create_materials_means_matrix(self):
        ''' generates a matrix of means for all material profiles '''

        query = qts.QSqlQuery(self.db)
        query.prepare('SELECT spectra from materials')
        query.exec_()
        i = 0
        meanslist = []
        while query.next():
            val = query.value(0).strip('[]')
            valList = val.split(', ')
            valList = list(map(float, valList))
            sampleList = [valList[i] for i in config.TARGET_BANDS]
            meanslist.append(list(sampleList))

        # print('meanslist is:', meanslist)
        # print('reporting means of material classes with shape', (len(meanslist), len(meanslist[0])))
        self.reportMeans.emit(meanslist)

        # Report the mean spectral signatures of each material class as an MxN array
        # where M is the number of material profiles stored in the db and N is the 
        # smallest number of bands recorded in the profile pixels (i.e. if most
        # of your stored pixels consist of 242 bands, but one of them is only 180 
        # bands, N will be 180 and the remaning band values will be truncated. This 
        # is why it is not recommended to combine pixels from various sensors into 
        # the same material profile library)


    def __init__(self):
        super().__init__()
        self.db = qts.QSqlDatabase.addDatabase('QSQLITE')
        self.db.setDatabaseName('data.db')
    
        if not self.db.open():
            error = self.db.lastError().text()
            qtw.QMessageBox.critical(
                None, 'DB Connection Error',
                'Could not open database file: ',
                f'{error}')
            sys.exit(1)
        else:
            print('connected to data.db')

        required_tables = {'materials', 'pixels', 'scans', 'sqlite_sequence'}
        tables = self.db.tables()
        missing_tables = required_tables - set(tables)
        if missing_tables:
            qtw.QMessageBox.critical(
                None, 'DB Integrity Error',
                'Missing tables, please repair DB: '
                f'{missing_tables}')
            sys.exit(1)
        else:
            print('DB integrity check - OK!')


class Downloader(qtc.QObject):
    """ An object for downloading HSI files in a separate thread """

    fileUnzipped = qtc.pyqtSignal(str)
    fileDownloaded = qtc.pyqtSignal(str)

    def unzip_it(self, zip_file):
        ''' Unzips file contents to downloads directory '''
        import zipfile
        dirname = os.getcwd()
        zippath = os.path.join(dirname, 'downloads')
        print(f'Unzipping to {zippath}')
        try:
            with zipfile.ZipFile(zip_file) as z:
                z.extractall(zippath)
                z.close()
                print("Extracted all contents of downloaded file")
            os.remove(zip_file)
        except Exception as e:
            print(e)

    def __init__(self, id, url):
        super().__init__()
        self.id = id
        self.url = url

    def download_hsi_file(self):
        ''' Opens download url and downloads zip file to downloads directory
        then tries to unzip it.'''

        print('Downloading to:', getcwd())
        r = requests.get(self.url)
        self.filename = self.id + '.zip'
        with open(self.filename, 'wb') as f:
            f.write(r.content)

        print(f'Download of {self.id} finished')
        self.fileDownloaded.emit(f'Download of {self.id} finished')

        try:
            self.unzip_it(self.filename)
            self.fileUnzipped.emit(self.id[:22])
        except:
            print('Error unzipping file %s.zip' % self.id)

        try:
            self.fix_header()
        except:
            print('Error making fix to header file')

    def fix_header(self):
        ''' Corrects error in Hyperion files where the header offset is 0 when it should be 2502 '''
        ''' The old header is stored as .bak and a new header file is created with the fix '''
        old_header = os.path.join(DOWNLOAD_PATH, self.filename[:-11], f'{self.filename[:-11]}.bak')
        header = os.path.join(DOWNLOAD_PATH, self.filename[:-11], f'{self.filename[:-11]}.hdr')

        # Making a new copy of header with adjusted offset of 2502
        os.rename(header, old_header)
        shutil.copyfile(old_header, header)

        file = open(header, 'r')
        replacement = ""
        for line in file:
            line = line.strip()
            changes = line.replace("header offset = 0", "header offset = 2502")
            replacement = replacement + changes + "\n"
        file.close()

        fout = open(header, 'w')
        fout.write(replacement)
        fout.close()


class LogIner(qtc.QObject):
    """ An object to control logging into USGS server """

    log_signal_true = qtc.pyqtSignal()
    log_signal_false = qtc.pyqtSignal()
    requestCredentials = qtc.pyqtSignal()
    loggedIn = False

    def __init__(self):
        super().__init__()
        self.username = ''
        self.password = ''  
        self.requestCredentials.emit() 

    def login(self):
        """ Login to USGS """
        payload = {'username' : self.username, 'password' : self.password}
        try:
            config.apiKey = self.to_dict(self.send_request(config.serviceUrl + "login", payload))
        except Exception as e:
            print(e)

        if config.apiKey:
            if config.apiKey['data']:
                # print("API Key: " + config.apiKey['data'] + "\n")
                self.login_success(config.apiKey['data'])
                self.log_signal_true.emit()
            else:
                self.login_failed(config.apiKey['errorCode'], config.apiKey['errorMessage'])
                self.send_log_signal(f"USGS Login failed!\t{config.apiKey['errorMessage']}")
        else:
            self.login_failed('No valid response.', 'USGS server may be down or you are not online.')
            self.send_log_signal('USGS Server is down or you are not connected to the internet')

    def refresh_api_key(self):
        payload = {'username' : self.username, 'password' : self.password}
        url = config.serviceUrl + 'login'
        json_data = json.dumps(payload)
        try:
            print('old API key:', config.apiKey)
            config.apiKey = None
            self.login()
            response = requests.post(url, json_data)
            print('response is', response.text)
            print('new key:', config.apiKey['data'])
            return True
        except Exception as e:
            response.close()
            print('!!!!!', e)
            return False

    def to_dict(self, j):
        ''' converts JSON to a python dictionary'''
        try:
            converted = json.loads(j)
            return converted
        except Exception as e:
            err = '\n### Did not receive valid JSON. USGS site may be down for maintenance\n\n'
            print(err.upper())
            print(e)
            return None


    def send_request(self, url, data, apiKey = None):  
        ''' sends an HTTP request to USGS server '''
        json_data = json.dumps(data)
        headers = {'X-Auth-Token': config.apiKey} 
        if config.apiKey:
            response = requests.post(url, json_data, headers = headers)  
            # print('\nsending with headers to %s: %s %s' % (url.replace(config.serviceUrl,''), data, headers)) 
        else:
            response = requests.post(url, json_data)
            # print('sending:', data) 

        # print('response is', response.text)

        if 'API key has expired' in response.text:
            self.log_signal_false.emit()
            print('API key expired. Logging in again...')
            if self.refresh_api_key():
                self.send_request(self, url, data, apiKey=config.apiKey)

        try:
            httpStatusCode = response.status_code 
            if response == None:
                print("No output from service")
                
            output = response.content
            
            if self.to_dict(output)['errorCode']:
                print(self.to_dict(output)['errorCode'], "- ", self.to_dict(output)['errorMessage'])
                
            if  httpStatusCode == 404:
                print("404 Not Found")
                
            elif httpStatusCode == 401: 
                print("401 Unauthorized")
                
            elif httpStatusCode == 400:
                print("Error Code", httpStatusCode)
            
        except Exception as e: 
            response.close()
            print(e)
                
            
        response.close()
        return output


    def find_file_size(self, r_id):
        '''Queries USGS database for file size and download url of a Hyperion scan'''
    
        dl_query = { 'entityIds': r_id,
                'datasetName' : 'EO1_HYP_PUB'}
        dl_info = self.send_request(config.serviceUrl + "download-options", dl_query, config.apiKey)
        dl_data = self.to_dict(dl_info)['data']
        
        dl_data = ast.literal_eval(str(dl_data[0]))
        r_productId = dl_data['id']
        r_filesize = round(int(dl_data['filesize']) / 1048576, 2)

        dl_query = { 'downloads' : [{'entityId': r_id,
                                'productId' : r_productId}],
                    'downloadApplication': 'EE'}
        dl_request = self.send_request(config.serviceUrl + "download-request", dl_query, config.apiKey)
        dl_data = self.to_dict(dl_request)['data']
        # print(dl_data)
        try:
            r_url = dl_data['availableDownloads'][0]['url']
        except:
            r_url = dl_data['preparingDownloads'][0]['url']
        finally:
            return r_filesize, r_url



    def login_success(self, apiKeyData):
        config.apiKey = apiKeyData
        self.loggedIn = True
        print('successfully logged in to USGS!')
        self.log_signal_true.emit()
    
    def login_failed(self, eCode, eText):
        self.loggedIn = False
        errorText = eCode +'\n'+ eText
        print(errorText)
        self.log_signal_false.emit()




